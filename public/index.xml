<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Paul O&#39;Day</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Paul O&#39;Day</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Paul O&#39;Day, 2024</copyright>
    <lastBuildDate>Sun, 03 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Psychedelic Quasicrystals in Rust</title>
      <link>http://localhost:1313/posts/rustquasi/</link>
      <pubDate>Sun, 03 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/rustquasi/</guid>
      <description>Rust quasicrystals This is part 2 of this article, where I go over the multithreaded Rust implementation. This will be quite a bit longer than going over the Clojure version, so I&amp;rsquo;m going to a do a part 3 where I take a look at how messing with different parameters affects the output. Part 1 goes more in depth on the math, so if you want to understand this program on a more abstract level that&amp;rsquo;s where to look.</description>
      <content>&lt;h1 id=&#34;rust-quasicrystals&#34;&gt;Rust quasicrystals&lt;/h1&gt;
&lt;p&gt;This is part 2 of &lt;a href=&#34;http://localhost:1313/&#34;&gt;this&lt;/a&gt; article, where I go over the multithreaded Rust implementation. This will be quite a bit longer than going over the Clojure version, so I&amp;rsquo;m going to a do a part 3 where I take a look at how messing with different parameters affects the output. Part 1 goes more in depth on the math, so if you want to understand this program on a more abstract level that&amp;rsquo;s where to look.&lt;/p&gt;
&lt;p&gt;The Rust version has more features than the Clojure version. You can adjust the zoom level as well offset the viewport. You can also adjust the angles of each layer independently, or make the angles of the layers change over the course of the animation, and you can adjust the speed of the animation. It&amp;rsquo;s also more documented and has a better architecture, so it should be easier to extend. We&amp;rsquo;ll go over it file by file, but I won&amp;rsquo;t look at every single function, just the interesting ones.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s an animation generated with 7 layers that have angles that change over the course of the animation. I don&amp;rsquo;t think it&amp;rsquo;s technically a quasicrystal (maybe for a few frames), but it is pretty neat:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;7 spinning layers&#34; src=&#34;http://localhost:1313/quasicrystals/spin.webp&#34;&gt;&lt;/p&gt;
&lt;p&gt;Command to generate these frames: &lt;code&gt;quasicrystals 200 200 0:100,0:86:100,0:72:100,0:58:100,0:44:100,0:30:100,0:16:100 20 -p -f 120 -t 4 -s 0 -c greyscale 127&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;optsrs&#34;&gt;opts.rs&lt;/h2&gt;
&lt;p&gt;This is where the input options are defined. I used &lt;a href=&#34;https://docs.rs/clap/latest/clap/&#34;&gt;clap&lt;/a&gt; to define the command line arguments, but the opts struct is generic and could be used by other Rust code if you wanted to use this as a library instead of a command line program. This would require some minor modification in &lt;code&gt;main.rs&lt;/code&gt; though.&lt;/p&gt;
&lt;h2 id=&#34;parsers&#34;&gt;parse.rs&lt;/h2&gt;
&lt;p&gt;This is where the input is parsed into data structures for the generation functions to use. Except for the angles and colorizer, everything can just be parsed with built in Rust parsers as you can see in &lt;code&gt;parse_image&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parse_image&lt;/span&gt;(opts: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Opts&lt;/span&gt;, frame: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Image&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Image {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        phases: &lt;span style=&#34;color:#a6e22e&#34;&gt;opts&lt;/span&gt;.speed,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        frame: &lt;span style=&#34;color:#a6e22e&#34;&gt;frame&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        frames: &lt;span style=&#34;color:#a6e22e&#34;&gt;opts&lt;/span&gt;.frames,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        scale: &lt;span style=&#34;color:#a6e22e&#34;&gt;opts&lt;/span&gt;.scale,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        width: &lt;span style=&#34;color:#a6e22e&#34;&gt;opts&lt;/span&gt;.width,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        height: &lt;span style=&#34;color:#a6e22e&#34;&gt;opts&lt;/span&gt;.height,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        x_offset: &lt;span style=&#34;color:#a6e22e&#34;&gt;opts&lt;/span&gt;.x_offset,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        y_offset: &lt;span style=&#34;color:#a6e22e&#34;&gt;opts&lt;/span&gt;.y_offset,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        angles: &lt;span style=&#34;color:#a6e22e&#34;&gt;parse_angles&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;opts.angles, frame, opts.frames, opts.percent),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This struct defines all the information we&amp;rsquo;ll need to get the 2d arrays of 0-1 values that represent shades. Converting them into pixels requires a colorizer. The function that does this is &lt;code&gt;parse_colorizer&lt;/code&gt; which basically translates some strings into a more formal struct, I won&amp;rsquo;t go over it here.&lt;/p&gt;
&lt;p&gt;Parsing the angles is more complex, as there are several ways to specify them. The most basic is a single number, which gets converted to a list of that many equal proportions, which is then converted to a list of angle rotations. You can also pass the proportions directly as a comma separated list of either fractions, percentages, or numbers. On top of that, all of these values can be changed over the course of the animation by passing multiple numbers separated by &amp;ldquo;:&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;A list of proportions is a description of how big the angles are in relation to each other. So 1,1,2 means 2 equal angles, then 1 angle that is twice as big as each of the first 2 (or as big as both of them combined). If you pass the -p (or &amp;ndash;percent) argument, you can specify the angles as fractions or percentages, so instead of 1,1,2 you could say 25,25,50, or 1/4,1/4,1/2. This allows you to pass a list of angles that don&amp;rsquo;t add up to a full circle, like 10,10,10.&lt;/p&gt;
&lt;p&gt;Parsing a list of percents is easy, we divide by 100 then multiply them by the unit circle (\(2\pi\) or \(\tau\)) to get the angle in radians.&lt;/p&gt;
&lt;p&gt;To handle a list of proportions we use &lt;code&gt;proportions_to_angles&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;proportions_to_angles&lt;/span&gt;(props: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; circle_sects &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TAU&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; props.iter().sum::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; sums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![props[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; p &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;props[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;] {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sum_to_p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sums.last().unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sums.push(sum_to_p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sums.iter().map(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; circle_sects).collect();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This takes a list of proportion values and converts them to angles of rotation for each layer. For example if our proportions are 1,2,1, the first layer is rotated 90 degrees, the next 180 degrees from the first, and the last 90 degrees from the second. First we find a common factor angle that can add up to each of these rotations. In this example it&amp;rsquo;d be 90. Then we make a list of how many of those angles we need to add up to the rotation for each layer. To do this we just add all the preceding values to each proportion in the list. So 1,2,1 becomes 1,3,4. Then we just multiply those values by the common factor angle to find the total rotation for each layer.&lt;/p&gt;
&lt;p&gt;To parse an angle we check if it&amp;rsquo;s an animation then either parse the animation or parse the string into a number, handling fractions if needed. This is done in &lt;code&gt;parse_angle&lt;/code&gt;. An animated angle is defined by &amp;ldquo;:&amp;rdquo; separated numbers which are basically keyframes to transition between. For example 1:10 means transition the number from 1 to 10 over the animation, so at half way &amp;ldquo;1:10&amp;rdquo; becomes &amp;ldquo;5&amp;rdquo;. Here&amp;rsquo;s the code to handle that:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parse_animation&lt;/span&gt;(anim_str: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;, frame: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;, frames: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; stages: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; anim_str.split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;:&amp;#39;&lt;/span&gt;).map(parse_maybe_frac).collect();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; trans_frames: &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; frames &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; (stages.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; from_stage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stages
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .get((frame &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; trans_frames).floor() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; to_stage &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stages
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .get((frame &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; trans_frames).ceil() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; trans_prog &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (frame &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; trans_frames) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; trans_frames;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (trans_prog &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (to_stage &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; from_stage)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; from_stage;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;Divide the number of frames by the number of animation stages to get the frames per stage&lt;/li&gt;
&lt;li&gt;Take current frame number and divide it by the frames per stage rounded down to get the stage we&amp;rsquo;re transitioning from. Then grab the number for that stage&lt;/li&gt;
&lt;li&gt;Then do the same but round up to get the number we&amp;rsquo;re transitioning to&lt;/li&gt;
&lt;li&gt;Take current frame % frames per stage to get how far into the stage we are, and divide it by frames per stage to get a percent. For example, if we&amp;rsquo;re on frame 10 and the stages are 3 frames each, we&amp;rsquo;re 1 frame into a stage, or 1/3 of the way through.&lt;/li&gt;
&lt;li&gt;The difference between the number we&amp;rsquo;re coming from and going to is how much the number changes over this stage, so multiply that by how far we are through the stage. Then we have to add the number we&amp;rsquo;re coming from to get the number for this frame&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;crystalrs&#34;&gt;crystal.rs&lt;/h2&gt;
&lt;p&gt;This file is basically where we implement the actual waveform generation. I won&amp;rsquo;t go over this it&amp;rsquo;s just a Rust version of the Clojure code with the addition of an offset factor for each coordinate.&lt;/p&gt;
&lt;h2 id=&#34;colorrs&#34;&gt;color.rs&lt;/h2&gt;
&lt;p&gt;These are the functions to convert the 0-1 shade values into colored pixel values. For greyscale we take a brightness factor from 0 (all black) to 255 (all white) and plug it into this formula: \(2*brightness - 255 + shade\) then convert it to an 8-bit number. This conversion will round the shade up or down and give us a greyscale image.&lt;/p&gt;
&lt;p&gt;For the sawtooth colors we just generate a sawtooth wave going from 0 to 255 over the course of the animation. Then for each color we select a point offset by some value, which is the percent through the wave that color will start. So if the offset is 0, we select 0 from the wave for the first frame, 127 for the halfway frame, and 255 for the last. If it&amp;rsquo;s 0.5 we select 127 for the first frame, 255 for the midpoint, and 126 for the last.&lt;/p&gt;
&lt;p&gt;For composite colors we take a range of shade values and a range of 8-bit color values for each color channel. Then we just convert from the shade range to the 8-bit range to get the pixel color. The ranges can overlap but they don&amp;rsquo;t have to. This is an implementation of the 3 color composite mapping mentioned &lt;a href=&#34;https://www.allthesky.com/articles/imagecolor.html&#34;&gt;here&lt;/a&gt;. Thee composite colors can be animated just like the angles, both the input and output ranges can be animated. For example, here&amp;rsquo;s 7 even layers with a composite animation but no phase or angle animation:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;7 layers with color animation&#34; src=&#34;http://localhost:1313/quasicrystals/coloranimation.webp&#34;&gt;&lt;/p&gt;
&lt;p&gt;To generate the frames of this animation: &lt;code&gt;quasicrystals 150 150 7 20 -p -f 48 -t 4 -s 0 -c composite 0:.3:.6:.3:0-.3:.6:1:.6:.3,.3:0:.3:.6:.3-.6:.3:.6:1:.6,.6:.3:0:.3:.6-1:.6:.3:.6:1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;outputrs&#34;&gt;output.rs&lt;/h2&gt;
&lt;p&gt;This is where the file writing happens. Currently there are two ways to output files, as a gif or as a series of frame images. Both of these are very simple, they just take a vector of image data structures and write them to the disk using the Rust Image library. Gif writing is supported by that library so we just pass the images along and it handles the rest. Frame writing is just a for loop that writes each image with the same library.&lt;/p&gt;
&lt;h2 id=&#34;mainrs&#34;&gt;main.rs&lt;/h2&gt;
&lt;p&gt;This is where everything gets tied together and multithreaded. By default it uses one thread, but you can specify more with the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; options. The &lt;code&gt;main&lt;/code&gt; function is pretty long we&amp;rsquo;ll look at it in parts.&lt;/p&gt;
&lt;p&gt;First we parse the input options, check if we have a valid output file, and decide how many threads to use. This is where the &lt;code&gt;parse.rs&lt;/code&gt; functions are called.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; opts: &lt;span style=&#34;color:#a6e22e&#34;&gt;input&lt;/span&gt;::Opts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; input::Opts::parse();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; frames &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; opts.frames;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; num_threads &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; frames &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; opts.threads {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        frames
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        opts.threads
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (sender, receiver) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; channel();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; opt_frames: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;RgbaImage&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec![None; frames &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; opts.image_format &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gif&amp;#34;&lt;/span&gt; { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; opts.output &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            println!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Must set output flag when writing gifs&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Path::new(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;opts.output).exists() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            println!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;File &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; exists, exiting&amp;#34;&lt;/span&gt;, opts.output);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println!(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Generating &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; frames at &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; with angles &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; and scale &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; using &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; threads&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        frames, opts.width, opts.height, opts.angles, opts.scale, num_threads
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    );
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then we spawn the thread(s) that generate the shade values for each frame:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; frames &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; num_threads &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; frame_thread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gen_frames_thread(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            frames,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            num_threads,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sender.clone(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            opts.verbose
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        frame_thread.join().unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; threads: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;thread::JoinHandle&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Vec::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; thread_num &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;num_threads {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            threads.push(gen_frames_thread(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    frames,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    num_threads,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    thread_num,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    sender.clone(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    opts.verbose
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; thread &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; threads {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            thread.join().unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We use channels to pass the frames back to the main thread, this is where they&amp;rsquo;re received. We have to receive them inside a struct that also has which frame it is, because they aren&amp;rsquo;t necessarily going to be sent back to the main thread in the correct order. To order them we have a vec with length equal to the number of frames, pre-initialized with None. When a frame is received, we take the frame data and put it into the correct spot of the vec wrapped in a Some.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Ok(result) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; receiver.try_recv() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        opt_frames[result.number &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(result.frame);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally we can pass the vec of Some(frame)s on to the image writing functions where they&amp;rsquo;ll be unwrapped and written to the output location:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; opts.image_format &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gif&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; opts.output.ends_with(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.gif&amp;#34;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        output::write_gif(opts.output, opt_frames, opts.allow_overwrite);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       output::write_frames(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           opts.image_format,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           opt_frames,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           opts.output.clone(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           opts.verbose,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           opts.allow_overwrite
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The threads are spawned with the &lt;code&gt;gen_frames_thread&lt;/code&gt; function. I&amp;rsquo;ll just summarize it since it&amp;rsquo;s pretty simple. It just calculates how many frames the thread should generate using the current thread number and the total number of frames. The last thread rounds up if needed, to account for the number of frames not splitting evenly into the number of threads. Then it&amp;rsquo;s just a for loop to call the &lt;code&gt;gen&lt;/code&gt; function from &lt;code&gt;crystal.rs&lt;/code&gt; for each frame. As each frame is generated, it&amp;rsquo;s put into a struct along with the frame number and sent back to &lt;code&gt;main.rs&lt;/code&gt; for final processing. This function is also where the colorizer is parsed from the command line.&lt;/p&gt;
&lt;p&gt;And that&amp;rsquo;s it! I glossed over a bunch to save space, but this should give you a pretty good idea of how this code is structured and what it does. In the next part of this series I won&amp;rsquo;t go over any code, instead I&amp;rsquo;ll look at a bunch of animations like this to get a more intuitive idea of where these patterns come from.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;spinning waves, animated colors&#34; src=&#34;http://localhost:1313/quasicrystals/spincolor.webp&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;quasicrystals 150 150 0:100,0:86:100,0:72:100,0:58:100,0:44:100,0:30:100,0:16:100 20 -p -f 120 -t 4 -s 0 -c composite 0:.3:.6:.3:0-.3:.6:1:.6:.3,.3:0:.3:.6:.3-.6:.3:.6:1:.6,.6:.3:0:.3:.6-1:.6:.3:.6:1&lt;/code&gt;&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>CLojure Quasicrystals</title>
      <link>http://localhost:1313/posts/clojurequasi/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/clojurequasi/</guid>
      <description>Years ago I read an article about how to generate a neat animation of a quasicrystal. A quasicrystal is an ordered structure that is not periodic. Because it&amp;rsquo;s ordered it can fill an infinite sized space, but since it&amp;rsquo;s not periodic it doesn&amp;rsquo;t have symmetry. The classic example of this is Penrose tiles, you can use them to fill any sized space by matching the colors of the tiles, but it doesn&amp;rsquo;t create a symmetrical repeating pattern.</description>
      <content>&lt;p&gt;Years ago I read an &lt;a href=&#34;http://mainisusuallyafunction.blogspot.com/2011/10/quasicrystals-as-sums-of-waves-in-plane.html&#34;&gt;article&lt;/a&gt; about how to generate a neat animation of a quasicrystal. A quasicrystal is an ordered structure that is not periodic. Because it&amp;rsquo;s ordered it can fill an infinite sized space, but since it&amp;rsquo;s not periodic it doesn&amp;rsquo;t have symmetry. The classic example of this is Penrose tiles, you can use them to fill any sized space by matching the colors of the tiles, but it doesn&amp;rsquo;t create a symmetrical repeating pattern. The animation mentioned in that article is composed of overlapping sine waves rotated at different angles.&lt;/p&gt;
&lt;p&gt;I thought this was extremely cool and had a lot of potential to make interesting psychedelic animations. Of course greyscale is boring, and I wanted to play around with the parameters, so I&amp;rsquo;d have to modify the original code. For example this image is generated with 7 overlapping waves rotated evenly from 0 to 360:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;7 layer quasicrystal&#34; src=&#34;http://localhost:1313/quasicrystals/7added.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;But what happens if angle one is 0, angle 2 is 180, and the rest are evenly split between 180-360? And what happens if we have 27 overlapping images?&lt;/p&gt;
&lt;p&gt;In an effort to answer these questions, I ported the original Haskell code to Clojure. I chose Clojure because it&amp;rsquo;s easy to play with parts of a program using the REPL, and I knew Clojure better than Haskell. This taught me how the math works, but it was also very slow. So instead of answering my questions with the Clojure version, I ported it to Rust so I could play around with it easier since I wouldn&amp;rsquo;t have to wait so long for animations to generate.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m going to split this into 2 articles to keep them focused. In this article I&amp;rsquo;ll use the simpler Clojure implementation to explain how these images are composed6; this should give you a good understanding of how this program works on an abstract level. Don&amp;rsquo;t worry if you don&amp;rsquo;t know Clojure, you should still be able to understand the basics from looking at the images and my explanations. Then, in the next article I&amp;rsquo;ll go over the more complex multi-threaded Rust implementation, and show off some cool animations.&lt;/p&gt;
&lt;h1 id=&#34;how-it-works&#34;&gt;How it works&lt;/h1&gt;
&lt;p&gt;The original post does a good job of explaining the math, but I&amp;rsquo;ll go over it again here. Each frame of these animations is composed of several waveforms projected into 2d space, rotated, and combined. Each wave form looks like a bunch of stripes - here the values from 0 to 1 are rendered as a gradient from black (0), to white (1):&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;A waveform with no rotation&#34; src=&#34;http://localhost:1313/quasicrystals/vertstripe.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;To animate it, we simply move the wave forward. The number that defines how far forward wave is moved is called the phase:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;A waveform animated&#34; src=&#34;http://localhost:1313/quasicrystals/vertanim.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;And this is the Clojure code to generate one frame of animation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;wave
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Returns waveform, the cos of all the y-values rotated by theta and moved
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;forward by phase&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  [theta x y phase]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[cth (&lt;span style=&#34;color:#a6e22e&#34;&gt;Math/cos&lt;/span&gt; theta)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sth (&lt;span style=&#34;color:#a6e22e&#34;&gt;Math/sin&lt;/span&gt; theta)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (/ (+ (&lt;span style=&#34;color:#a6e22e&#34;&gt;Math/cos&lt;/span&gt; (+ (* cth x) (* sth y) phase)) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A more formal way to write the equation in this function would be:&lt;/p&gt;
$$ \frac{\cos(x\cos(\theta) + y\sin(\theta) + phase) + 1}{2} $$
&lt;p&gt;Where \(\theta\) is the angle of the wave (e.g. 0 means the stripes are vertical), and \(phase\) is a number from 0-1. Note that this only generates numbers between 0 and 1, translating those into pixels of an image is a later step.&lt;/p&gt;
&lt;p&gt;Next we have a simple function to generate a list of numbers evenly spaced between 0 and \(\pi\). These are the angles of the different layers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;angles
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Returns a list of n angles between 0 and PI&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  [n]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (for [m (range n)] (* m (/ Math/PI n))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is done by taking each number from 0 to \(n\) and multiplying them by \(\pi\)/\(n\). These numbers will be fed into the theta argument of the wave function.&lt;/p&gt;
&lt;p&gt;Next we have to combine the images. To do this we add the numbers of each pixel together, then wrap it between 0 and 1. This means is as the summed value goes from 0 to 1 the wrapped output goes from 0 to 1, then as the sum goes from 1 to 2 the wrapped output goes from 1 to 0, then 2-3 outputs 0 to 1, etc. For example adding two perpendicular waves gives us this:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;2 waveforms added and wrapped&#34; src=&#34;http://localhost:1313/quasicrystals/2added.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;This is the Clojure code to add and wrap values&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;combine
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Combines a list of values, and wraps the result between 1 and 0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  [wavs]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;[ws (reduce + wavs)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;odd?&lt;/span&gt; (int ws))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (- &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;mod&lt;/span&gt; ws &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (&lt;span style=&#34;color:#a6e22e&#34;&gt;mod&lt;/span&gt; ws &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To make the wrapped output we simply sum the inputs, then use the modulus operator to isolate the decimal part. Then if the non-decimal part is odd we&amp;rsquo;re going from 1 to 0, so we subtract the decimal part from 1. If the non-decimal is even we can just return the decimal part.&lt;/p&gt;
&lt;p&gt;Finally we can combine these into a function that generates the values for one frame of animation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;defn &lt;/span&gt;crystal
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Returns a vector in the form [x y shade] where shade is the color at x and y&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  [max-x max-y phase num-angles]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (for [x (range max-x) y (range max-y)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [x y
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     (&lt;span style=&#34;color:#a6e22e&#34;&gt;combine&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (map (&lt;span style=&#34;color:#66d9ef&#34;&gt;fn &lt;/span&gt;[th] (&lt;span style=&#34;color:#a6e22e&#34;&gt;wave&lt;/span&gt; th x y phase))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           (&lt;span style=&#34;color:#a6e22e&#34;&gt;angles&lt;/span&gt; num-angles)))]))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function takes the x and y dimensions, phase (aka frame of animation), and how many overlapping waves to use. It&amp;rsquo;s pretty straightforward; we just use the angles function to make a list of angles, then map the wave function over that list, then use the combine function to sum and wrap each value. This is repeated for each pixel of the image, and voila, we have the color values for a single frame.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s what it looks like when we add 3, 4, and 5 layers:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;3 waveforms added and wrapped&#34; src=&#34;http://localhost:1313/quasicrystals/3added.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;4 waveforms added and wrapped&#34; src=&#34;http://localhost:1313/quasicrystals/4added.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;5 waveforms added and wrapped&#34; src=&#34;http://localhost:1313/quasicrystals/5added.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m not sure when these start being quasicrystals, but my goal is to make neat animations so I don&amp;rsquo;t really care. The original article used 7 layers, and 3 definitely isn&amp;rsquo;t a quasicrystal. 4 seems like it is, so maybe it&amp;rsquo;s every number after 3, but it might not be zoomed out enough to see the full pattern. As you add more layers you have to zoom out to see an interesting pattern, here&amp;rsquo;s 19 layers with the same zoom as the previous images:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;19 waveforms added and wrapped&#34; src=&#34;http://localhost:1313/quasicrystals/19added.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;And a zoomed out and enlarged version:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;19 waveforms added and wrapped, zoomed out&#34; src=&#34;http://localhost:1313/quasicrystals/19addedsmaller.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;I won&amp;rsquo;t go into detail for writing those values to an image or generating a list of frames as there are a lot of ways to do it and the way I picked is pretty slow. The summary is: I used Java&amp;rsquo;s &lt;code&gt;BufferedImage&lt;/code&gt; class and a function to translate the 0-1 values into RGB values to output each frame as a jpg, then combined those with imagemagick into an animation. Combining them into a gif using Clojure was tricky and by that time I had already decided to make a Rust version.&lt;/p&gt;
&lt;h1 id=&#34;adding-color&#34;&gt;Adding Color&lt;/h1&gt;
&lt;p&gt;The function to translate a 0-1 value into a RGB pixel (i.e. 3 values from 0-255) is worth talking about. This is where you can get creative, there are a lot of ways to translate a value between 0 and 1 to a color. Astronomers have &lt;a href=&#34;https://www.allthesky.com/articles/imagecolor.html&#34;&gt;explored&lt;/a&gt; this problem, as many telescopes only give a grayscale image, and adding color helps understand what they&amp;rsquo;re seeing. The simplest is obviously using 0 as one color (e.g. black) and 1 as another (e.g. white) for a basic gradient. One way I came up with is to map each r, g, and b value to a sawtooth wave that goes from 0 to 255, starting with some offset. For example an offset of 0.5 would start at 128 then go through 255, back to 0, then up to 128 again over the course of the animation. I believe this is just a way of implementing an animated version of the false color composite from that astronomy page, but I could be wrong - I just made it up to get something colorful. This is 6 overlapping layers with a red offset of 0, green of 0.25, and blue of 0.5:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;6 added waveforms colorized&#34; src=&#34;http://localhost:1313/quasicrystals/colorful6added.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;This is very cool, but also very slow to generate, taking around 10 minutes on my old Macbook. In the next article I&amp;rsquo;ll go over the multithreaded Rust implementation of this program which is much faster. I also added a couple more parameters to tweak (such as zoom level), so I&amp;rsquo;ll show a gallery of animations generated with different settings. The code is on &lt;a href=&#34;https://github.com/pauloday/quasicrystals/tree/master&#34;&gt;Github&lt;/a&gt;, the &lt;a href=&#34;https://github.com/pauloday/quasicrystals/tree/clojure&#34;&gt;Clojure&lt;/a&gt; version is in a branch.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      <description>I’m a full-stack developer with a passion for learning and building things. If I had to describe my career in one phrase, it would be “jumping right into the deep end”. My coding journey began around age 11 when I started writing games in QuickBasic. This ignited my passion for learning about programming as I started a tour through various other languages and paradigms, eventually ending with Javascript as my main language - although I’m always eager to learn new things, especially when it’s about the best tool for the job.</description>
      <content>&lt;p&gt;I’m a full-stack developer with a passion for learning and building things. If I had to describe my career in one phrase, it would be “jumping right into the deep end”. My coding journey began around age 11 when I started writing games in QuickBasic. This ignited my passion for learning about programming as I started a tour through various other languages and paradigms, eventually ending with Javascript as my main language - although I’m always eager to learn new things, especially when it’s about the best tool for the job.
Along the way I found Linux and spent many hours installing various distributions and tinkering with configurations. Though I&amp;rsquo;ve spent countless frustrated hours in the command line messing with config files I love Linux, and really believe it&amp;rsquo;s the best operating system out there. I&amp;rsquo;ve always been drawn to solving hard problems, so if you have any feel free to reach out!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/pauloday&#34;&gt;Github&lt;/a&gt; &lt;a href=&#34;https://www.linkedin.com/in/paul-oday/&#34;&gt;Linkedin&lt;/a&gt;&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
